#include <string.h>
#include <SPI.h>
#include <PubSubClient.h>	// http://knolleary.net/arduino-client-for-mqtt/
#include <Ethernet.h>
#include <EEPROM.h>
#include <TrueRandom.h>

/*
 * tempmonitor2mqtt (C)2014 by Jan-Piet Mens
 * This Arduino sketch reads a simulates a temperature sensor and periodically
 * publishes the obtained value to an MQTT broker. The simulation is done
 * with a potentiometer: when set to 0, the program reports random values
 * between 10 and 40 "degrees", otherwise a "flattened" potentiometer
 * setting.
 * The sketch also announces itself as being "alive" by publishing
 * a "1" to WILLTOPIC when it successfully connects, and by
 * instructing the broker to publish on its behalf (LWT) a "0" when
 * it dies.
 */

#define WILLTOPIC	"clients/arduino/%s"
#define TEMPTOPIC	"clients/arduino/%s/celsius"
// #define MQTT_SERVER	"192.168.1.130"
#define MQTT_SERVER	"10.0.69.162"
#define MQTT_PORT	1889
#define USER	NULL
#define PASS	NULL
#define WILLMESSAGE	"0"
#define TRUE		(1)
#define RETAIN		(1)

#define BUZZER_PIN	A3
#define LED_PIN		A1
#define POTENTIOMETER_PIN	A0	 

#undef DEBUG

#ifdef DEBUG
# define DINFO()	Serial.print(millis()); Serial.print(": "); \
			Serial.print(__FUNCTION__); Serial.print("():"); \
			Serial.print(__LINE__); Serial.print(" > ");
# define DPRINT(...)	Serial.print(__VA_ARGS__)
# define DPRINTLN(...)	Serial.println(__VA_ARGS__)
#else
# define DINFO()
# define DPRINT(...)
# define DPRINTLN(...)
#endif

/*
 * http://nicegear.co.nz/blog/autogenerated-random-persistent-mac-address-for-arduino-ethernet/
 */
byte mac[] = { 0x90, 0xA2, 0xDA, 0x00, 0x00, 0x00 };

unsigned long dhcpfreq	= (60 * 60 * 1000);	// milliseconds between DHCP lease check
unsigned long lastdhcp	= 0L;

unsigned long tempfreq	= (5 * 1000);		// milliseconds between temperature PUB
unsigned long lasttemppub = 0L;
int lastpotval = -1;

char ip_str[16];				// dotted decimal
char willtopic[128];
char clientid[30];

void callback(char *topic, byte *payload, unsigned int length);
EthernetClient eth;
PubSubClient mqtt(MQTT_SERVER, MQTT_PORT, callback, eth);

void setup() {                

#ifdef DEBUG
	Serial.begin(9600);
#endif
	DPRINTLN("startup");

	pinMode(POTENTIOMETER_PIN, INPUT);
	pinMode(LED_PIN, OUTPUT);
	pinMode(BUZZER_PIN, OUTPUT);
	digitalWrite(BUZZER_PIN, HIGH);

	randomSeed(analogRead(0));

	/*
	 * Do we have a previously generated MAC address in EEPROM? If
	 * so, use it, otherweise generate one randomly and store it.
	 */
	
	if (EEPROM.read(1) == '#') {
		for (int i = 3; i < 6; i++) {
			mac[i] = EEPROM.read(i);
		}
	} else {
		for (int i = 3; i < 6; i++) {
			mac[i] = TrueRandom.randomByte();
			EEPROM.write(i, mac[i]);
		}
		EEPROM.write(1, '#');
	}

	while (Ethernet.begin(mac) != 1) {
		DPRINTLN("Failed to config DHCP");
		delay(30000);
	}

	DPRINTLN(Ethernet.localIP());

	*ip_str = 0;
	for (int n = 0; n < 4; n++) {
		sprintf(ip_str + strlen(ip_str), "%d", Ethernet.localIP()[n]);
		if (n < 3)
			strcat(ip_str, ".");
	}
	
	sprintf(willtopic, WILLTOPIC, ip_str);
	sprintf(clientid, "arduino-%s", ip_str);

}

boolean mqttconnect() {
	if (!mqtt.connected()) {
		/*
		 * Connect to the broker. In the event we die, the broker
		 * will, on our behalf, publish a retained "0" to the will topic.
		 */

		if (mqtt.connect(clientid, USER, PASS, willtopic, MQTTQOS2, RETAIN, WILLMESSAGE)) {

			/*
			 * Tell the world that we are online, by publishing a retained
			 * "1" onto our will topic.
			 */
			mqtt.publish(willtopic, (byte *)"1", strlen("1"), RETAIN);

			mqtt.subscribe("clients/arduino/led/cmd");
			mqtt.subscribe("clients/arduino/led");		/* Is it retained "on"? */
		} else {
			DPRINTLN("Cannot connect to broker; abort!");
			while (1)
				;
		}
	}
	return mqtt.connected();
}

void loop() {
	static char topic[128], payload[24];
	int potval, degrees;

	while (!mqttconnect()) {
		delay(10000);
	}

	if ((millis() - lastdhcp) > dhcpfreq) {
		lastdhcp = millis();

		/* Renew DHCP lease if necessary */
		DINFO();
		DPRINTLN(" .. renew DHCP lease");
		Ethernet.maintain();
	}

	potval = analogRead(POTENTIOMETER_PIN);
	potval = map(potval, 0, 1023, 0, 40);	// flatten electric value to "temp C"
	potval = (potval > 38) ? 40 : potval;	// it 'wobbles' otherwise

	if ((potval != lastpotval) || ((millis() - lasttemppub) > tempfreq)) {
		lasttemppub = millis();
		lastpotval = potval;

		/* PUBlish temperature, retained */

		sprintf(topic, TEMPTOPIC, ip_str);

		degrees = (!potval) ? random(16, 25) : potval;
		sprintf(payload, "%d", degrees);

		DINFO();
		DPRINT("PUB ");
		DPRINT(topic);
		DPRINT(" ");
		DPRINTLN(payload);
		mqtt.publish(topic, (byte *)payload, strlen(payload), RETAIN);
	}

	mqtt.loop();
}

void callback(char *topic, byte *payload, unsigned int length)
{
	char buff[128], t[2];
	int n, on;

        for (n = 0; (n < length) && (n < sizeof(buff) - 1); n++) {
                buff[n] = payload[n];
        }
        buff[n] = 0;

	/* See comment #50 at http://knolleary.net/arduino-client-for-mqtt/#comment-62272 */

	DINFO();
	DPRINT(topic);
	DPRINT(" -> ");
	DPRINTLN(buff);

	/* On power up, restore state of LED from the retained message */
	if (strcmp(topic, "clients/arduino/led") == 0) {
		on = atoi(buff) ? HIGH : LOW;
		digitalWrite(LED_PIN, on);
	}
	if (strcmp(topic, "clients/arduino/led/cmd") == 0) {
		on = atoi(buff) ? HIGH : LOW;

		digitalWrite(LED_PIN, on);

		digitalWrite(BUZZER_PIN, LOW);
		delay(100);
		digitalWrite(BUZZER_PIN, HIGH);

		strcpy(t, (on) ? "1" : "0");
		mqtt.publish("clients/arduino/led", (byte *)t, strlen(t), RETAIN);
	}
}
